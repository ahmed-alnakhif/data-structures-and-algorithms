# Data Structure

| #   | Title | Solution                              | Basic Idea |  O Notation  |
| --- | ----- | ------------------------------------- | ---------- | ------------ |
| 1   | Linked List | [java](src/dataStructures/LinkedList.java) | 1. a node that has a pointer to another node | 1. searching/inserstion/deletion at the beginning or end: O(1) <br>2. O(N) for a specific index
| 2   | Binary Tree | [java](src/dataStructures/Trees.java) | 1. left child is smaller than root <br>2. right child is larger than root | 1. searching: O(log(N)) <br>2. insertion O(log(N)) <br>3. deletion: O(log(N))
| 3   | Priority Queue | [java](src/dataStructures/PriorityQ.java) | 1. min PQ: root is always the smallest <br>2. max PQ: root is always the largest | 1. fetching: O(1) <br>2. insertion O(log(N)) <br>3. deletion: O(log(N))
| 4   | Graphs | [java](src/dataStructures/Graph.java) | we can use adjacency list to represent graphs | 1. searching: O(E) <br>2. has a path: O(E) |

<br><br>

# Algorithms
| #   | Title         | Solution                                    | Basic Idea |  O Notation  |
| --- | ------------- | ------------------------------------------- | ---------- | ------------ |
| 1   | Permutation   | [Java](src/algorithms/PermutationList.java) | use recursion <br>1. base case is when left == array length <br>2. swap left with i <br>3. call recursive function and increment left <br>4. swap again to revert back | O(N!) |
| 2   | [Combinations](https://leetcode.com/problems/combinations/) | [Java](src/Problems/Combination/Combinations.java) | 1. base case is when comb size == k <br>2. iterate from start to required length <br>3. add curr to comb list <br>4. call func recursively with i+1 <br>5. backtrack by removing the last added number | T: O(r * rCn) = O(n!/r!(n-r)!) <br>S: O(r * rCn) |
| 3   | [Subsets](https://leetcode.com/problems/subsets/)  | [java](src/algorithms/Subset.java)  | 1. iterate through the list <br>2. get each subset in the result list, add the current number to it, and then add the new subset to the result list  | O(2^N) |
| 4   | Binary Search | [java](src/algorithms/BinarySearch.java) | 1. set a most left & most right pointer <br>2. while pointers don't cross each other, calculate mid index <br>3. check if mid value equals the target | O(log(N)) |
| 5   | Quick Sort | [java](src/algorithms/QuickSort.java) |  | O(N^2) |
| 6   | Quick Select | [java](src/algorithms/searching/QuickSelect.java) |  | O(N^2) |

<br><br>

# Patterns

## 1) Sliding Window
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Maximum Sum Subarray of Size K](https://www.educative.io/courses/grokking-the-coding-interview/JPKr0kqLGNP) | [Java](src/Problems/SlidingWindow/MaximumSumSubarrayOfSizeK.java) | 1. calculate the sum of the first subarray of size k <br>2. slide the window until the end of the array <br>3. while sliding, calculate the sum and compare with max | T: O(N) <br>S: O(1) |
|  2  | [Smallest Subarray With a Greater Sum](https://www.educative.io/courses/grokking-the-coding-interview/7XMlMEQPnnQ) | [Java](src/Problems/SlidingWindow/MinSizeSubArraySum.java) | 1. if sum < k, then we add right element to sum <br>2. if sum >= k, we subtract the left element from sum and keep track of min | T: O(N) <br>S: O(1) |
|  3  | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)  | [Java](src/Problems/SlidingWindow/LongestSubstringWithoutRepeatingCharacters.java) | 1. left and right pointer <br>2. set to track if we've seen the character before <br>3. if we have seen the character, remove the left most char <br>4. else, add to set and compare set size with max| T: O(N) <br>S: O(N) |
|  4  | [Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)  | [Java](src/Problems/SlidingWindow/LongestSubstringwithAtMostKDistinctCharacters.java) | 1. add char to map with its index <br>2. remove the char if it already exists <br>3. if map size > k, remove the left most element in the map and set left to the index + 1 <br>4. keep track of max | T: O(N) <br>S: O(N) |
|  5  | [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)  | [Java](src/Problems/SlidingWindow/FruitIntoBaskets.java) | same as [Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/) | T: O(N) <br>S: O(N) |
|  6  | [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)  | [Java](src/Problems/SlidingWindow/LongestRepeatingCharacterReplacement.java) | 1. freq map and track max freq character <br>2. if window size - max freq char > k, keep removing the left character <br>3. keep track of max window length | T: O(N) <br>S: O(N) |
|  7  | [Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/) | [Java](src/Problems/SlidingWindow/MaxConsecutiveOnes.java) | 1. if 1, increment count <br>2. if 0, then reset count <br>3. keep track of max | T: O(N) <br>S: O(1) |
|  8  | [Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/) | [Java](src/Problems/SlidingWindow/MaxConsecutiveOnesII.java) | 1. if num is zero, decrement allowed number of zeros <br>2. if allowedZeros < 0, slide window and increase allowedZeros if num is zero | T: O(N) <br>S: O(1) | 
|  9  | [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/) | [Java](src/Problems/SlidingWindow/MaxConsecutiveOnesIII.java) | 1. same as [Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/) | T: O(N) <br>S: O(1) | 
|  10  | [Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences/) | [Java](src/Problems/SlidingWindow/RepeatedDNASequences.java) | fixed window, and a hash map to check for DNA occurrence | T: O(N) <br>S: O(N) |
|  11  | [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/) | [Java](src/Problems/SlidingWindow/FindAllAnagramsInString.java) | 1. fixed window, and a hash map for each string <br>2. check if both hash maps are equal | T: O(S) <br>S: O(26)
|  12  | [Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/) | [Java](src/Problems/SlidingWindow/SubarrayProductLessThanK.java) | 1. calculate product <br>2. if product is greater than K, then remove left most num and increment left <br>3. then calculate count = count + window size and increment right | T: O(N) <br>S: O(N) |

## 2) Two Pointers
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [2 Sum](https://leetcode.com/problems/max-consecutive-ones/) | [Java](src/Problems/SlidingWindow/MaxConsecutiveOnes.java) | 1. expand window to the right and keep count of 1s <br>2. if 0, then reset count | T: O(N) <br> S: O(N) |
|  2  | [3 Sum](https://leetcode.com/problems/3sum/) | [Java](src/Problems/TwoPointers/ThreeSum.java) | using two pointers <br>1. sort the array first <br>2. iterate and find the two sum from i + 1| T: O(N^2) <br>S: O(1) |
|  3  | [4 Sum](https://leetcode.com/problems/4sum/) | [Java](src/Problems/TwoPointers/FourSum.java) | 3sum + 2 sum | T: O(N^3) <br>S: O(N) |
|  4  | [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) | [Java](src/Problems/TwoPointers/RemoveDuplicates.java) | 1. if left != right, increment left <br>2. left = right | T: O(N) <br>S: O(1) |
|  5  | [Remove Element](https://leetcode.com/problems/remove-element/) | [Java](src/Problems/TwoPointers/RemoveElement.java) | 1. if right != val, left = right and increment left  | T: O(N) <br>S: O(1)
|  6  | [Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array) | [Java](src/Problems/TwoPointers/SquaresOfSortedArray.java) | 1. check the largest absolute value between left and right, and place the square value at the end of the result array <br>2. adjust right or left pointers accordingly  | T: O(N) <br>S: O(1) 
|  7  | [3Sum Closest](https://leetcode.com/problems/3sum-closest/) | [Java](src/Problems/TwoPointers/Sum3Closest.java) | using two pointers <br>1. sort the array first <br>2. iterate and find the two sum from i + 1 <br>3. calculate the closest difference to the target | T: O(N^2) <br>S: O(1) |
|  8  | [3Sum Smaller](https://leetcode.com/problems/3sum-smaller/) | [Java](src/Problems/TwoPointers/Sum3Smaller.java) | using two pointers <br>1. sort the array first <br>2. iterate and find the two sum from i + 1 <br>3. check if sum is smaller than target | T: O(N^2) <br>S: O(1) |
|  9  | [Sort Colors](https://leetcode.com/problems/sort-colors/) | [Java](src/Problems/TwoPointers/SortColors.java) | 1. if 0 => swap(i++, left++) <br>2. if 1 => i++ <br>3. if 2 => swap(i++, right++) | T: O(N) <br>S: O(1) |
|  10 | [Backspace String Compare](https://leetcode.com/problems/backspace-string-compare/) | [Java](src/Problems/TwoPointers/BackspaceStringCompare.java) | two pointer: <br>1. start from the end of the string <br>2. two inner while loops to count backspaces <br>3. compare if current char in s != t<br> can also be solved using a stack | T: O(N+M) <br>S: O(1)) |
|  11 | [Shortest Subarray to be Removed to Make Array Sorted](https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/) | [Java](src/Problems/TwoPointers/ShortestSubarrayToBeRemoved.java) |  | T: O(N) <br>S: O(1) |
|  12 | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) | [Java](src/Problems/TwoPointers/ContainerWithMostWater.java) | 1. left and right pointer <br>2. get the area of min(arr[left], arr[right]) <br>3. keep track of the max area <br>4. move the shorter colum | T: O(N) <br>S:O(1) |
|  13 | [Trapping Rain Water](https://leetcode.com/problems/container-with-most-water/) | [Java](src/Problems/TwoPointers/TrappingRainWater.java) | 1. track leftMax and rightMax <br>2. if leftMax < rightMax, add leftMax - height[left] to the result <br>3. else, add rightMax - height[right] | T: O(N) <br>S:O(1) |


## 3) Fast and Slow Pointers
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) | [Java](src/Problems/fastAndSlowPointers/MiddleOfLinkedList.java) | 1. fast and slow pointer <br>2. return the slow pointer | T: O(N) <br>S: O(1)
|  2  | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | [Java](src/Problems/fastAndSlowPointers/LinkedListCycle.java) | 1. a fast pointer that moves two steps <br>2. if fast ptr == slow, then there's a cycle | T: O(N) <br> S: O(1)
|  3  | [Linked List CycleII](https://leetcode.com/problems/linked-list-cycle-ii/) | [Java](src/Problems/fastAndSlowPointers/LinkedListCycleII.java) | 1. a fast pointer that moves two steps <br>2. find intersection node <br>3. traverse from intersect node and a new head ptr until they reach each other <br>4. return ptr | T: O(N) <br> S: O(1)
|  4  | [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) | [Java](src/Problems/fastAndSlowPointers/FindDuplicateNumber.java) | Floyd's Algorithm | T: O(N) <br>S: O(1)
|  5  | [Happy Number](https://leetcode.com/problems/happy-number/) | [Java](src/Problems/fastAndSlowPointers/HappyNumber.java) | Floyd's Algorithm <br>2. calculate next digit by using mod operator and division <br>3. use Floyd's algorithm to calculate fast and slow pointer <br>4. check also if fast == 1 (happy number) | T: O(log(N)) <br>S: O(1)
|  6  | [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) | [Java](src/Problems/fastAndSlowPointers/PalindromeLinkedList.java) | 1. get the end of the first half <br>2. reverse the second half <br>3. check if each respective nodes are equal | T: O(N) <br>S: O(1)
|  7  | [Reorder Linked List](https://leetcode.com/problems/reorder-list/) | [Java](src/Problems/fastAndSlowPointers/ReorderLinkedList.java) | 1. get the end of the first half <br>2. reverse the second half <br>3. merge the two lists | T: O(N) <br>S: O(1)


## 4) Intervals
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Merge Intervals](https://leetcode.com/problems/merge-intervals/) | [Java](src/Problems/Intervals/MergeIntervals.java) | 3 conditions: <br>1. sort intervals <br>2. toAdd < curr => add toAdd result list and update toAdd = curr <br>3. toAdd > curr => add curr to result list <br>4. toAdd & curr overlap => update toAdd min and max | T: O(N*log(N)) <br>S: O(N)
|  2  | [Insert Interval](https://leetcode.com/problems/insert-interval/) | [Java](src/Problems/Intervals/InsertInterval.java) | same is merge intervals <br> if intervals are sorted then skip the first step | T: O(N) <br>S: O(N)
|  3  | [Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/) | [Java](src/Problems/Intervals/IntervalListIntersections.java) | 1. find max of start between the two lists <br>2. find min of end between the two lists <br>3. if start<=end, add start and end to result <br>4. increment who has smaller end | T: O(N + M) <br>S: O(N + M)
|  4  | [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/) | [Java](src/Problems/Intervals/MeetingRooms.java) | 1. sort intervals <br>2. check if end is smaller than next start | T: O(N*log(N)) <br>S: O(1)
|  5  | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/) | [Java](src/Problems/Intervals/MeetingRoomsII.java) | 1. create an array for start time and array for end time then sort them <br>2. iterate and increment count <br>3. if start >= end decrement count | T: O(N*log(N)) <br>S: O(N)
|  6  | [Car Pooling](https://leetcode.com/problems/car-pooling/) | [Java](src/Problems/Intervals/CarPooling.java) | 1. use TreeMap or PQ <br>2. add start time with + passengers <br>3. add end time with - passengers <br>4. get the accumulative sum of values <br>if > capacity then false | T: O(N*log(N)) <br>S: O(N)
|  7  | [Employee Free Time](https://leetcode.com/problems/employee-free-time/) | [Java](src/Problems/Intervals/EmployeeFreeTime.java) | 1. flatten all employees intervals <br>2. sort all intervals <br>3. merge intersected intervals <br>4. add end time and start time of the next interval | T: O(N*log(N)) <br>S: O(N)


## 5) Cyclic Sort
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [First Missing Positive](https://leetcode.com/problems/first-missing-positive/) | [Java](src/Problems/cyclicSort/FirstMissingPositive.java) | 1. sort nums using cyclic sort <br>2. return first unmatched index | T: O(N) <br>S: O(1) |
|  2  | [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/) | [Java](src/Problems/cyclicSort/FirstKthMissingPositive.java) | using binary search | T: O(log(N)) <br>S: O(1) |


## 6) Linked Lists
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Merge Two Linked Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [Java](src/Problems/LinkedLists/MergeLinkedLists.java) | 1. while second list is not empty, make l1.next -> l2, and make l2.next -> l1  | T: O(M + N) <br>S: O(1) |
|  2  | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [Java](src/Problems/kWayMerge/MergeTwoSortedLists.java) | 1. min heap to hold the head of the two lists <br>2. poll min top and connect pointers <br>3. return head  <br>** check recursive approach for optimized solution| T: O(N * log(2)) <br>S: O(1) |
|  3  | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) | [Java](src/Problems/LinkedLists/ReverseLinkedList.java) | 1. curr & prev pointers <br>2. iterate through the linked list and reverse | T: O(N) <br>S: O(1) |
|  4  | [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) | [Java](src/Problems/LinkedLists/ReverseLinkedListII.java) | 1. get left and right nodes <br>2. reverse sub linked list <br>3. connect pointers | T: O(N) <br>S: O(1) |
|  5  | [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/) | [Java](src/Problems/LinkedLists/CopyListWithRandomPointers.java) | 1. first iteration, add all nodes to a hash map <br>2. second iteration, map.get(curr).next = map.get(curr.next) <br> and map.get(curr).random = map.get(curr.random) <br> lastly, we return map.get(head) | T: O(N) <br>S: O(N) |
|  6 | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) | [Java](src/Problems/LinkedLists/AddTwoNumbers.java) | 1. same approach as [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) <br>2. handle carrier | T: O(max(M, N)) <br>S: O(1) |
|  7  | [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/) | [Java](src/Problems/LinkedLists/SwapNodesPairs.java) | 1. create dummy head <br>2. swap between first 2 nodes <br>3. move prev and head to next pairs | T: O(N) <br>S: O(1) |
|  8  | [Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/) | [Java](src/Problems/LinkedLists/SwapNodesInLinkedList.java) | 1. get front and end nodes <br>2. swap values | T: O(N) <br>S: O(1) |
|  9  | [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/) | [Java](src/Problems/LinkedLists/ReverseNodesInKGroup.java) | 1. set left and right of sub linkedlist in a loop < LL length <br>2. head = reverseLinkedListII with left and right| T: O(N) <br>S: O(1) |
|  10  | [Rotate Linked List](https://leetcode.com/problems/rotate-list/) | [Java](src/Problems/LinkedLists/RotateLinkedList.java) | 1. get the tail and length <br>2. calculate new tail k%length <br>3. link oldTail to head <br>4. move newTail ptr to new tail position <br>5. set newHead to newTail.next <br>6. set newTai.next to null| T: O(N) <br>S: O(1) |


## 8) Tree - Breadth First Search
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | [Java](src/Problems/TreeBreadthFirstSearch/BinaryTreeLevelOrderTraversal.java) | 1. regular BFS <br>2. save queue size and loop < size <br>3. add polled node to your level list <br>4. after loop is done, add the level list to the final result list | T: O(N) <br>S: O(N) |
|  2  | [Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) | [Java](src/Problems/TreeBreadthFirstSearch/BinaryTreeLevelOrderTraversalII.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. after loop is done, add the level list to the beginning of result instead | T: O(N) <br>S: O(N) |
|  3  | [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) | [Java](src/Problems/TreeBreadthFirstSearch/BinaryTreeZigzagLevelOrderTraversal.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. one orderd level and one reversed <br>3. have a boolean variable; if reverse then add at the end, else add first | T: O(N) <br>S: O(N) |
|  4  | [Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/) | [Java](src/Problems/TreeBreadthFirstSearch/AverageOfLevelsInBinaryTree.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. get accumulative sum and count of each level <br>3. add sum/count to result | T: O(N) <br>S: O(N) |
|  5  | [Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/) | [Java](src/Problems/TreeBreadthFirstSearch/MaximumLevelSumOfBinaryTree.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. keep track of max sum and level | T: O(N) <br>S: O(N) |
|  6  | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | [Java](src/Problems/TreeBreadthFirstSearch/MaximumDepthOfBinaryTree.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. keep incrementing depth and return it | T: O(N) <br>S: O(N) |
|  7  | [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) | [Java](src/Problems/TreeBreadthFirstSearch/MinimumDepthOfBinaryTree.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. keep incrementing depth <br>3. if curr node is a leaf node, return depth | T: O(N) <br>S: O(N) |
|  8  | [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/) | [Java](src/Problems/Trees/BinaryTreeRightSideView.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. add node to result if we reach the end of a level | T: O(N) <br>S: O(N) |
|  9  | [Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) | [Java](src/Problems/TreeBreadthFirstSearch/PopulatingNextRightPointers.java) | 1. [BFS](https://leetcode.com/problems/binary-tree-level-order-traversal/) <br>2. node points to next in the queue if node is not the last in the level | T: O(N) <br>S: O(N) |


## 9) Tree - Depth First Search
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Path Sum](https://leetcode.com/problems/path-sum/) | [Java](src/Problems/TreeDepthFirstSearch/PathSum.java) | 1. preorder DFS <br>2. keep track of accumulative sum <br>3. if sum = target AND is leaf node then return true <br>4. else check if left OR right is true | T: O(N) <br>S: O(N) |
|  2  | [Path Sum II](https://leetcode.com/problems/path-sum-ii/) | [Java](src/Problems/TreeDepthFirstSearch/PathSumII.java) | 1. preorder DFS <br>2. keep track of accumulative sum and traversed nodes<br>3. if sum = target AND is leaf node then add list to result <br>4. else check left and right <br>5. remove last node from list | T: O(N) <br>S: O(N) |
|  3  | [Path Sum III](https://leetcode.com/problems/path-sum-iii/) | [Java](src/Problems/TreeDepthFirstSearch/PathSumIII.java) | 1. preorder DFS <br>2. use the same concept in [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) <br>3. check left and right subtrees <br>4. remove curr sum from map, so we don't us it with other subtrees paths | T: O(N) <br>S: O(N) |
|  4  | [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) | [Java](src/Problems/TreeDepthFirstSearch/BinaryTreePaths.java) | 1. preorder DFS <br>2. keep track of traversed nodes<br>3. if leaf node then add list to result <br>4. else check left and right <br>5. remove last node from list | T: O(N) <br>S: O(N) |
|  5  | [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/) | [Java](src/Problems/TreeDepthFirstSearch/SumRootToLeafNumbers.java) | 1. preorder DFS <br>2. keep track of sum<br>3. if leaf node then add sum to totalSum <br>4. else, check left and right | T: O(N) <br>S: O(H); H is the tree height to keep the recursion stack |
|  6  | [Path With Given Sequence](https://www.educative.io/courses/grokking-the-coding-interview/m280XNlPOkn) | [Java](src/Problems/TreeDepthFirstSearch/PathWithGivenSequence.java) | 1. preorder DFS <br>2. keep track of sum<br>3. if leaf node then add sum to totalSum <br>4. else, check left and right | T: O(N) <br>S: O(N) |
|  7  | [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) | [Java](src/Problems/TreeDepthFirstSearch/DiameterOfBinaryTree.java) | 1. diameter = longest path in left subtree + right subtree  <br>2. get left and right longest path <br>3. track max diameter <br>4. return max between left and right + 1| T: O(N) <br>S: O(N) |
|  8  | [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) | [Java](src/Problems/TreeDepthFirstSearch/MaximumPathSum.java) | 1. global variable to track max <br>2. get max gain for left and right subtrees <br>3. sum subtree gain (root+left+righ) <br>4. update maxSum <br>5. return root value and max of left or right | T: O(N) <br>S: O(N) |


## 10) Two Heaps
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) | [Java](src/Problems/twoHeaps/MedianFinder.java) | 1. create a minHeap and maxHeap <br>2. minHeap will hold the left side and maxHeap will hold the right side <br>3. find the median by getting the top of minHeap and maxHeap | T: O(log(N)) <br>S: O(N) |
|  2  | [Sliding Window Median](https://leetcode.com/problems/sliding-window-median/) | [Java](src/Problems/twoHeaps/SlidingWindowMedian.java) | based on [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) <br>1. use TreeSet instead of PQ <br>2. if window size is greater than k, then we remove from both heaps <br>3. add num <br>4. if we have a full window, then we add median to result | T: O(N*log(N)) <br>S: O(N) |
|  3  | [IPO](https://leetcode.com/problems/ipo/) | [Java](src/Problems/twoHeaps/IPO.java) | the idea is to maximize the profit and minimize the capital <br>1. max heap for profit & min heap for capital <br>2. while our available capital is less than the min cap, then we have to take it <br> we add the profit of the project to our avail cap | T: O(N*log(N)) <br>S: O(N) |
|  4  | [Find Right Interval](https://leetcode.com/problems/find-right-interval/) | [Java](src/Problems/twoHeaps/FindRightInterval.java) | the idea is to access the max end time and compare it with max start time <br>1. two max heaps for start and end times <br>2. check if top end time is less than top start time, if true then we find a possible right interval. <br>3. however, we still need to check if there's a smaller start time | T: O(N*log(N)) <br>S: O(N) |


## 11) Subsets
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Subsets](https://leetcode.com/problems/subsets/) | [Java](src/Problems/Subsets/Subsets.java) | Cascading <br>1. start with an empty list <br>2. an outer loop to iterate through numbers <br>3. an inner loop to grab each subset and add num to it | T: O(N*2^N) <br>S: O(N*2^N) |
|  2  | [SubsetsII](https://leetcode.com/problems/subsets-ii/) | [Java](ssrc/Problems/Subsets/SubsetsII.java) | same as [Subsets](https://leetcode.com/problems/subsets/), but calculate the starting index for the inner loop to be the beginning of duplicates | T: O(N*N!) <br>S: O(N!) |
|  3  | [Permutations](https://leetcode.com/problems/permutations/) | [Java](src/Problems/Permutations/Permutation.java) | 1. use backtracking <br> 2. base case is when left == list size <br>3. swap(left, i) <br>4. call func recursively with left+1 <br>5. backtrack by swapping again | T: O(N*2^N) <br>S: O(N*2^N) |
|  4  | [Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation/) | [Java](src/Problems/Permutations/LetterCasePermutation.java) | 1. same as [Permutations](https://leetcode.com/problems/permutations/) <br>2. if letter, perform permutation twice; one with upper case and one with lower case <br>if number perform permutation once | T: O(N*2^N) <br>S: O(N*2^N) |
|  5  | [Combinations](https://leetcode.com/problems/combinations/) | [Java](src/Problems/Combination/Combinations.java) | 1. base case is when comb size == k <br>2. iterate from start to required length <br>3. add curr to comb list <br>4. call func recursively with i+1 <br>5. backtrack by removing the last added number | T: O(r * rCn) = O(n!/r!(n-r)!) <br>S: O(r * rCn) |
|  6  | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) | [Java](src/Problems/Permutations/GenerateParentheses.java) | 3 conditions <br>1. base case: add subset if open == close == n <br>2. add open if open < n <br>3. add close if close < open  | T: O(N*2ᴺ) <br>S: O(N*2ᴺ) |
|  7  | [Different Way to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/) | [Java](src/Problems/Subsets/DiffWaysToAddParentheses.java) |  |  |
|  8  | [Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees) | [Java](src/Problems/dynamicProgramming/tabulation/UniqueBinarySearchTrees.java) | using dp <br> apply Catalan number formula | T: O(N^2)/O(N) S: O(N) |
|  9  | [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/) | [Java](src/Problems/dynamicProgramming/UniqueBinarySearchTreesII.java) |  | T: O( ) S: O( ) |


## 12) Modified Binary Search
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Binary Search](https://leetcode.com/problems/binary-search/) | [Java](src/Problems/modifiedBinarySearch/BinarySearch.java) | 1. left and right pointers <br>2. mid = (left+right)/2 <br>3. if val < target, divide the array and move left to mid + 1 <br>4. if val > target, divide the array and move right to mid - 1 | T: O(log(N)) <br>S: O(1) |
|  2  | [Search Insert Position](https://leetcode.com/problems/search-insert-position/) | [Java](src/Problems/modifiedBinarySearch/SearchInsertPosition.java) | 1. same as binary search. But if we didn't find the value, then we return left instead of -1 | T: O(log(N)) <br>S: O(1) |
|  3  | [Smallest Letter Greater Than Target](https://leetcode.com/problems/find-smallest-letter-greater-than-target/) | [Java](src/Problems/modifiedBinarySearch/SmallestLetterGreaterThanTarget.java) | the idea is to find the point where left crosses right, and then return one character ahead. if they didn't cross; meaning that target is in the array, then we return right | T: O(log(N)) <br>S: O(1) |
|  4  | [First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)  | [Java](src/Problems/modifiedBinarySearch/FirstandLastPositionOfElement.java) | 1. first find the position of the target <br>2. scan right side <br> 3. scan left side | Time: O(log(N)) <br> Space: O(1) |
|  5  | [First and Last Position of Element in Sorted Array](https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/) | [Java](src/Problems/modifiedBinarySearch/SearchSortedArrayOfUnknownSize.java) | 1. find the right bound by comparing reader with target. if value > target then we found the upper bound <br>2. regular binary search | Time: O(log(N)) <br> Space: O(1) |
|  6  | [First and Last Position of Element in Sorted Array](https://leetcode.com/problems/search-suggestions-system/) | [Java](src/Problems/modifiedBinarySearch/SearchSuggestionsSystem.java) | The idea here is to use prefix substrings from search word and use binary search to find if there're any words that start with the prefix substring in our products list. <br>1. sort products <br>2.  | Time: O(log(N)) <br> Space: O(1) |


## 13) Top Kth Elements
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) | [Java](src/Problems/topKElements/KthLargestElement.java) | 1. min heap to hold k elements <br>2. traverse and add nums to min heap. <br>3. if size > k then poll so we only keep the largest k elements <br>4. return top in the heap | T: O(N * log(k)) <br>S: O(k) |
|  2  | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) | [Java](src/Problems/topKElements/TopKFrequentElements.java) | 1. map to count frequency <br>2. min heap to hold k elements <br>3. iterate through map and add words to min heap. <br>4. if size > k then poll so we only keep the largest k elements <br>4. return all elements in min heap | T: O(N * log(k)) <br>S: O(k) |
|  3  | [Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/) | [Java](src/Problems/topKElements/TopKFrequentWords.java) | 1. map to count frequency <br>2. min heap to hold k elements <br>3. iterate through map and add words to min heap. <br>4. if size > k then poll so we only keep the largest k elements <br>4. return all elements in min heap in a reversed order | T: O(N * log(k)) <br>S: O(k) |
|  4  | [Sort Chars By Frequency](https://leetcode.com/problems/top-k-frequent-words/) | [Java](src/Problems/topKElements/SortCharactersByFrequency.java) | 1. map to count frequency. Whenever we see an existing char, we increase the string as well <br>2. min heap to get max freq first <br>3. return all elements in max heap| T: O(N * log(N)) <br>S: O(N) |
|  5  | [Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) | [Java](src/Problems/topKElements/KthLargestElementInStream.java) | 1. use min heap <br>2. maintain heap size whenever we add an item | T: O(N * log(N)) <br>S: O(N) |
|  6  | [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/) | [Java](src/Problems/topKElements/FindKClosestElements.java) | combination of binary search and two pointers <br>1. use BS to find closest element <br>2. initialize left and right pointer to get expand outward <br>3. once we have our window size, build the result from left to right | T: O(log(N) + k) <br>S: O(1) |
|  7  | [Least Number of Unique Integers after K Removals](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/) | [Java](src/Problems/topKElements/LeastNumberOfUniqueIntegers.java) | 1. map to count occurrence <br>2. min Heap <br>3. subtract k from each top element in the min heap <br>3. if k is positive, return heap size, else heap size + 1 | T: O(N*log(N)) <br>S: O(N) |
|  8  | [Sum of Elements](https://www.educative.io/courses/grokking-the-coding-interview/qVljv3Plr67) | [Java](src/Problems/topKElements/SumOfElements.java) | the idea is to calculate the sum between k1 and k2 <br>1. add all elements to a min heap <br>2. remove elements up to k1 <br>3. calculate total sum up to k2-k1-1 | T: O(N*log(N)) <br>S: O(N) |
|  9  | [Reorganize String](https://leetcode.com/problems/reorganize-string/) | [Java](src/Problems/topKElements/SumOfElements.java) | 1. HashMap for freq and Max Heap <br>2. prev entry which is set to null first <br>3. curr entry we poll while heap is not empty <br>4. if prev is not null then we add it <br>5. add curr and set prev to curr  | T: O(N*log(N)) <br>S: O(N) |
|  10  | [Rearrange String k Distance Apart](https://leetcode.com/problems/rearrange-string-k-distance-apart/) | [Java](src/Problems/topKElements/ReorganizeStringKDistanceApart.java) | 1. same idea as [Reorganize String](https://leetcode.com/problems/reorganize-string/) 2. instead, we just need to have a queue and push curr element and wait for queue size == k to add the element back to the heap | T: O(N*log(N)) <br>S: O(N) |
|  11  | [Task Scheduler](https://leetcode.com/problems/task-scheduler/) | [Java](src/Problems/topKElements/TaskScheduler.java) |  | T: O(N*log(N)) <br>S: O(N) |
|  12  | [Maximum Frequency Stack](https://leetcode.com/problems/maximum-frequency-stack/) | [Java](src/Problems/topKElements/MaxFrequencyStack.java) | freq map and max heap | T: O(N*log(N)) <br>S: O(N) |
|  13  | [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/) | [Java](src/Problems/topKElements/KClosestPointsToOrigin.java) | max heap <br>1. add each point with its distance to the heap <br>2. poll if size > k | T: O(N*log(N)) <br>S: O(N) |


## 14) K-Way Merge
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [Java](src/Problems/kWayMerge/MergeTwoSortedLists.java) | 1. min heap to hold the head of the two lists <br>2. poll min top and connect pointers <br>3. return head  <br>** check recursive approach for optimized solution| T: O(N * log(2)) <br>S: O(2) |
|  2  | [Merge K Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [Java](src/Problems/kWayMerge/MergeTwoSortedLists.java) | same approach as [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) <br> we just need to add all the roots of all lists| T: O(N * log(K)) <br>S: O(K) |
|  3  | [Kth Smallest Number in Sorted Lists](https://www.educative.io/courses/grokking-the-coding-interview/myAqDMyRXn3) | [Java](src/Problems/kWayMerge/KthSmallestNumberInSortedLists.java) | 1. add the first cells from all lists to the min heap <br>2. while our min heap is not empty, pop the first element <br>3. if count == k, then we reached our kth number <br>4. if popped element array still has elements, then we increment index of element and add it to the min heap | T: O(K * log(M)) <br>S: O(M) |
|  4  | [Kth Smallest Number in Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) | [Java](src/Problems/kWayMerge/KthSmallestNumberInSortedMatrix.java) | same as [Kth Smallest Number in Sorted Lists](https://www.educative.io/courses/grokking-the-coding-interview/myAqDMyRXn3) <br> optimized approach using binary search | T: O(min(K,N)+K∗logN) <br>S: O(N) |
|  5  | [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/) | [Java](src/Problems/kWayMerge/SmallestRange.java) | same approach but extra trackers <br>1. add the head of each list to min heap <br>2. track the max head <br>3. while we have all lists in our heap, poll top and calculate the new range <br>4. update the range if less  | T: O(N*log(M)) <br>S: O(M) |
|  6  | [Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) | [Java](src/Problems/kWayMerge/FindKSmallestPairs.java) | 1. min heap <br>2. create a pair by iterating through the first list and the first element in the second list <br>3. while we're larger than k, pop the top element and add it to the result <br>4. increment index of second list and add it to the min heap | T: O(K*log(K)) <br>S: O(K) |
|  7  | [Find K Pairs with Largest Sums](https://www.educative.io/courses/grokking-the-coding-interview/N767x7VoYmK) | [Java](src/Problems/kWayMerge/FindKLargestPairs.java) |  | T: O(K*log(K)) <br>S: O(K) |

## 15) Graphs
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Has Path]() | [Java]() | use DFS or BFS | T: O(E+V) <br>S:O(V) |  
|  2  | [Island Count](https://leetcode.com/problems/number-of-islands/) | [Java](src/Problems/Graphs/NumberOfIslands.java) |  | T:O(N * M) <br>S:O(N * M) | 

## 16) Dynamic Programming
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
| 1.1 | [Fibonacci](https://leetcode.com/problems/fibonacci-number/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/Fib.java) | 1. base case: n <= 2 return 1 <br> 2. recursive case: n = (n-1) + (n-2) | T: O(n) <br>S: O(n) |
| 1.2 | [Fibonacci](https://leetcode.com/problems/fibonacci-number/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/Fib.java) | 1. create a table of size n + 1 <br>2. initialize i(0) = 0, i(1) = 1 <br>3. table[i] = table[i-1] + table[i-2] | T: O(n) <br>S: O(n) |
| 2.1 | [Unique Paths](https://leetcode.com/problems/unique-paths/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/GridTraveler.java) | 1. base case: if we reached the end of either row or col, return 0 <br>2. base case: we have only one cell, return 1 <br>3. recursive case: sum of shrinking by one row down + one col right | T: O( ) <br>S: O( ) |
| 2.2 | [Unique Paths](https://leetcode.com/problems/unique-paths/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/GridTraveler.java) | 1. create a 2d table of size n+1, m+1 <br>2. base case: init table[1][1] = 1 <br>3. curr cell = left cell + bottom cell| T: O( ) <br>S: O( ) |
| 3.1 | [Can Sum](https://leetcode.com/problems/two-sum/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/CanSum.java) | 1. base case: if target == 0, return true <br>2. base case: if target < 0, return false <br>3. recursive case: iterate through our options and calculate the remainder and pass it to the recursive func as a target <br>4. if the returned value is true, then return true <br>5. if we finished the loop, then there's no answer, return false | T: O(M * N) <br>S: O(M) |
| 3.2 | [Can Sum](https://leetcode.com/problems/two-sum/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/CanSum.java) | 1. create a table of size target + 1 <br>2. base case: table[0] = true <br>2. recursive case: iterate through the tables cell <br>3. if the curr cell is true, then go through all the options we have, and set the table[i+option] = true | T: O(M * N) <br>S: O(M) |
| 4.1 | [Count Sum](https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/m27pwPZ3yvG) | memoization: [Java](src/Problems/dynamicProgramming/memoization/CanSum.java) | 1. base case: if targetSum == 0, return 1 <br>2. base case: if targetSum < 0 || reached the end of the array, return 0 <br>3. recursive case: call recursive function one with the decision to include the number and one without the number <br>4. keep track of the count value return from each recursive calls and return it| T: O(M * N) <br>S: O(M) |
| 4.2 | [Count Sum](https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/m27pwPZ3yvG) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/CanSum.java) | 1. create a 2d table of size [nums.length+1][target+1] <br>2. init base case dp[0][0] = 1 <br>3. start from the second row, and iterate through each col <br>4. decision not to take would be the upper cell <br>5. decision to take would be dp[num - 1][sum - currSum] <br>5. return the bottom right cell value | T: O(M * N) <br>S: O(M) |
| 5.1 | [How Sum](https://leetcode.com/problems/two-sum/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/HowSum.java) | 1. base case: if target == 0, return an empty list <br>2. base case: if target < 0, return null <br>3. recursive case: iterate through all the options and calculate the remainder <br>4. call the recursive function and save it into a list <br>5. if the list is not null then we add the current option and backtrack | T: O(N*M^2) <br>S: O(M^2) |
| 5.2 | [How Sum](https://leetcode.com/problems/two-sum/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/HowSum.java) | 1. create a table of size target + 1 <br>2. base case: table[0] = an empty list <br>2. recursive case: iterate through the tables cell <br>3. if the curr cell is not null, then iterate through all the options we have, and copy the list at the curr index + option into table[i+option] | T: O(N*M^M) <br>S: O(M^2) |
| 6.1 | [Smallest Sum](https://leetcode.com/problems/two-sum/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/BestSum.java) | 1. base case: if target == 0, return an empty list <br>2. base case: if target < 0, return null <br>3. recursive case: iterate through all the options and calculate the remainder <br>4. call the recursive function and save it into a list <br>5. if the list is not null then we add the current option <br>6. check if the new created list < shortest combination list and update if true <br>7. return the shortest list | T: O(N*M^2) <br>S: O(M^2) |
| 6.2 | [Smallest Sum](https://leetcode.com/problems/two-sum/) | tabulation: [Java]() | 1. create a table of size target + 1 <br>2. base case: table[0] = an empty list <br>2. recursive case: iterate through the tables cell <br>3. if the curr cell is not null, then iterate through all the options we have <br>4. copy the list at the curr index + option into table[i+option] if it's smaller than the existing list | T: O(N*M^M) <br>S: O(M^2) |
| 7.1 | [Can Construct](https://leetcode.com/problems/word-break/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/CanConstruct.java) | 1. base case: if target is an empty string, return true <br>2. recursive case: iterate through each word in our word bank <br>3. if the word is at the beginning of the target word, then we chop the target and pass the substring to the recursive function <br>4. return true if the func returns true | T: O(N*M^2) <br>S: O(M) |
| 7.2 | [Can Construct](https://leetcode.com/problems/word-break/) | tabulation: [Java](src/Problems/dynamicProgramming/memoization/CanConstruct.java) | 1. create a table of size target + 1 <br>2. base case: table[0] = true <br>2. recursive case: iterate through the tables cell <br>3. if the curr cell is true, then go through all the options we have <br>4. get the substring from i -> option length <br>5. if the substring == option, then we set the value at table[i + option.length] = true <br>6. return the last index value | T: O(N*M^2) <br>S: O(M) |
| 8.1 | [All Construct](https://leetcode.com/problems/word-break/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/AllConstruct.java) | 1. base case: if target is an empty string, return a 2d empty list <br>2. recursive case: iterate through each word in our word bank <br>3. if the word is at the beginning of the target word, then we chop the target and pass the substring to the recursive function <br>4. update the result list so each sublist includes the word | T: O(N^M) <br>S: O(N^M) |
| 8.2 | [All Construct](https://leetcode.com/problems/word-break/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/AllConstruct.java) | 1. create a table of size target + 1 <br>2. initialize an empty list inside each cell <br>3. add another empty list inside the base case i=0 <br>4. recursive case: iterate through the tables cell <br>5. iterate through each word <br>6. get the substring from i -> option length <br>7. if the current word == substring, we copy the word into each subList and copy the new list into table[i + word.length]<br> 8. return the last cell | T: O(N^M) <br>S: O(N^M) |
| 9 | [Word Break II](https://leetcode.com/problems/word-break-ii/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/WordBreakII.java) | same concept in All Construct <br> put an empty string in each cell instead of an empty list | T: O(N^M) <br>S: O(N^M) |
| 10.1 | [0/1 Knapsack Problem](https://www.educative.io/courses/grokking-the-coding-interview/gkZNLjV2kBk) | memoization: [Java](src/Problems/dynamicProgramming/memoization/Knapsack.java) | 1. base case: our available capacity is <= 0 OR index reached the end <br>3. recursive case: 2 recursive calls, one with the decision to add up the item, and one without it. <br>4. return the Max between the two | T: O(N*C) <br>S: O(N*C) |
| 10.2 | [0/1 Knapsack Problem](https://www.educative.io/courses/grokking-the-coding-interview/gkZNLjV2kBk) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/Knapsack.java) | 1. create a 2d table of size [weights.length][capacity+1] <br>2. initialize the first row with the first profit if its weight is less than the capacity <br>3. profitByNotPickingUpItem = upper cell <br>4. profitByPickingUpItem = profits[row] + dp[row - 1][cap - weights[row]] <br>5. then we get the max between the two choices <br>6. return the last cell | T: O(N*C) <br>S: O(N*C) |
| 11.1 | [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) | memoization: [Java](src/Problems/dynamicProgramming/memoization/PartitionEqualSubsetSum.java) | we can construct equal partition if we find a combination for total sum / 2 <br>1. base case: if total sum is odd, then there's no way to partition <br>2. base case: if we reached a sum of zero, return true <br>3. if index reached the end of the array or sum < 0, return false <br>4. recursive case: call recursive method one with taking the decision to subtract num from sum and one without <br>5. return if either is true | T: O(M*N) <br>S: O(M*N) |
| 11.2 | [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) | memoization: [Java](src/Problems/dynamicProgramming/tabulation/PartitionEqualSubsetSum.java)  | 1. create a table of size [nums.length + 1][totalSum/2 + 1] <br>2. base case: dp[0][0] = true <br>3. recursive case: starting from the second row, if current sum > sum, then we can't take it, so we put the above cell value <br>4. else, we put the value of the above cell OR the max cell we can take from the above row <br>5. return the last cell | T: O(M*N) <br>S: O(M*N) |
| 12.1 | [Minimum Subset Sum Difference](https://www.educative.io/courses/grokking-the-coding-interview/mE53y85Wqw9) | memoization: [Java](src/Problems/dynamicProgramming/memoization/MinSubsetSumDifference.java) | 1. base case: index reach the end of array length <br>2. recursive case: call recursive function two times; one by including the option to first set sum, and one by including the option to the second set sum <br>3. return the min between first and second | T: O(N * Sum(N)) <br>S: O(N * Sum(N)) |
| 12.2 | [Minimum Subset Sum Difference](https://www.educative.io/courses/grokking-the-coding-interview/mE53y85Wqw9) | tabulation: [Java](src/Problems/dynamicProgramming/memoization/MinSubsetSumDifference.java) | the idea is to try to find the half of total sum in both sides, so difference would be zero <br>1. we can use the same approach in [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) <br>2. we iterate from the bottom right cell, and find first cell that's trye <br>3. if true, then it means we can generate this particular sum <br>4. calculate the second partition by taking the difference between total sum and first partition sum <br>5. finally, return abs value of the difference | T: O(N * Sum(N)) <br>S: O(N * Sum(N)) |
| 13 | [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) | tabulation: [Java](src/Problems/dynamicProgramming/tabulation/LongestCommonSubsequence.java) | 1. create a 2d table of size text1+1 and text2+1 <br>2. iterate through each cell and apply 2 rules <br>3. if matching character, then get the prev diagonal value + 1 <br>4. else, get the max of upper and left cell | T: O(M*N) <br>S: O(M*N) |
| 14 | [Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) | [Java](src/Problems/dynamicProgramming/UniqueBinarySearchTrees.java) |  | T: O(N^2) <br>S: O(N) |
| 15 | [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/) | [Java](src/Problems/dynamicProgramming/UniqueBinarySearchTreesII.java) |  | T: O(N^2) <br>S: O(N) |
| 16 | [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/) | [Java](src/Problems/dynamicProgramming/UniqueBinarySearchTreesII.java) |  | T: O(N^2) <br>S: O(N) |


## 17) Topological Sort
|  #  | Title                       | Solution                    | Basic Idea                                    |  O Notation  |
| --- | --------------------------- | --------------------------- | --------------------------------------------- |------------- |
|  1  | [Topological Sort Algorithm](https://www.educative.io/courses/grokking-the-coding-interview/m25rBmwLV00) | [Java](src/Problems/topologicalSort/TopologicalSortAlgorithm.java) | 1. build a graph and an in-degree map <br>2. create a source queue (nodes that have 0 in-degree edges) <br>3. while the queue is not empty: <br>  a. poll the node  <br>  b. decrement the children degree <br>  c. if child degree == 0, add it to the queue <br>4. check if we were able to add all the nodes to the result list | T:O(V+E) <br>S:O(V+E) |
|  2  | [Course Schedule](https://leetcode.com/problems/course-schedule/) | [Java](src/Problems/topologicalSort/CourseSchedule.java) | 1. same approach as [Topological Sort Algorithm](https://www.educative.io/courses/grokking-the-coding-interview/m25rBmwLV00) <br>2. count the courses inside the while block <br>3. return if count == totalCourses | T:O(V+E) <br>S:O(V+E) |
|  3  | [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) | [Java](src/Problems/topologicalSort/CourseScheduleII.java) | 1. same approach as [Topological Sort Algorithm](https://www.educative.io/courses/grokking-the-coding-interview/m25rBmwLV00) | T:O(V+E) <br>S:O(V+E) |
|  4  | [All Scheduling Tasks](https://www.educative.io/courses/grokking-the-coding-interview/q2YmVjQMMr3) | [Java](src/Problems/topologicalSort/AllTaskSchedulingOrders.java) | 1. same approach as [Topological Sort Algorithm](https://www.educative.io/courses/grokking-the-coding-interview/m25rBmwLV00) <br>2. instead of only polling sources from the queue, have a recursive function that does that <br>3. for every source node, remove source, decrement degrees and then backtrack | T:O(V!*E) <br> S:O(V!*E)) |
|  5  | [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/) | [Java](src/Problems/topologicalSort/AlienDictionary.java) |  | T:O(V+N) <br> S:O(V+N) |
|  6  | [Sequence Reconstruction](https://leetcode.com/problems/sequence-reconstruction/) | [Java](src/Problems/topologicalSort/SequenceReconstruction.java) |  | T:O() <br> S:O() |
|  7  | [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/) | [Java](src/Problems/topologicalSort/MinimumHeightTrees.java) |  | T:O() <br> S:O() |



## 18) Other
|  #  | Title         | Solution                                    | Basic idea |  O Notation  |   Pattern   |
| --- | ------------- | ------------------------------------------- | ---------- | ------------ | ----------- |
|  1  | [Two Sum](https://leetcode.com/problems/two-sum/)  | [Java](src/Problems/Sequences/TwoSum.java) | 1. HashMap <br>2. for loop to check if complement exists in the map | O(N) |
|  2  | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)  | [Java](src/Problems/Sequences/BestTimeToBuyAndSell.java) | 1. HashSet <br>2. for loop to check if complement exists in the set | O(N) |
|  3  | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | [Java](src/Problems/Sequences/ContainsDuplicate.java) | 1. keep track of the minimum price <br>2. keep track of the max profit | O(N) |
|  4  | [Valid Anagram](https://leetcode.com/problems/valid-anagram/)  | [Java](src/Problems/Sequences/ValidAnagram.java) | 1. HashMap <br>2. add occurrence of first string chars and then subtract occurrence from second string <br>3. map values should be 0 | O(N) |
|  5  | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)  | [Java](src/Problems/Sequences/ProductOfArrayExceptSelf.java) | 1. calculate product and number of zeros <br>2. check number of zeros and return the proper product | O(N) |
|  6  | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)  | [Java](src/Problems/Sequences/ValidParentheses.java) | 1. use a stack to push open brackets <br>2. check if next char is matching closing bracket && stack is empty at the end | O(N) |
|  7  | [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)  | [Java](src/Problems/SlidingWindow/MaxSubarray.java) | 1. iterate and count the sum <br>2. reset if sum + nums[i] is negative <br>3. keep track of max subarray | O(N) |
|  8  | [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)  | [Java](src/Problems/TwoPointers/TwoSumII.java) | 1. use a left and a right pointer <br>2. check if the sum is equal to the target <br>3. increment left if sum is lower, decrement right if sum is larger | O(N) |
|  9  | [Three Sum Sorted](https://leetcode.com/problems/3sum/)  | [Java](src/Problems/TwoPointers/ThreeSum.java) | 1. two nested loop; first loop gets the first value, and second loop performs 2Sum (find 2 values == target) <br>2. Array must be sorted to avoid duplicates <br>3. we can use L & R pointers, hashSet, or binary search to solve 2Sum| O(N^2) |
|  10 | [Three Sum Unsorted](https://leetcode.com/problems/3sum/)  | [Java](src/Problems/TwoPointers/ThreeSum.java) | 1. since the array is not sorted, we can avoid duplicate by sorting the 3 values before adding them to the resultSet list and if the new set is not new, it won't be added again| O(N^2) |
|  11 | [Group Anagrams](https://leetcode.com/problems/group-anagrams/)  | [Java](src/Problems/Sequences/GroupAnagram.java) | sort each word and put it in a map where key is the word and value is a list of the words that match the sorted word| O(n* wLog(w)) | 
|  12 | [Max Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)  | [Java](src/Problems/Sequences/MaxProductSubarray.java) |  | O(N) | 
| 13   | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)  | [Java](src/Problems/Sequences/SearchRotatedSortedArray.java) |  | O(log(N))  | 
| 14   | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)  | [Java](src/Problems/LinkedLists/ReverseLinkedList.java) | track prev node, traverse the linked list and switch next pointer  | O(N)  | 
| 15   | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)  | [Java](src/Problems/LinkedLists/LinkedListCycle.java) | 1. a slow and a faster pointer <br>2. if fast == slow, then there's a cycle  | O(N)  | 
| 16   | [Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)  | [Java](src/Problems/Sequences/MinimumInRotatedSortedArray.java) | 1. use binary search logic <br>2. if mid < right -> search left side <br>3. if mid > right -> search right side  | O(log(N))  | 
| 17   | [Number of Islands](https://leetcode.com/problems/number-of-islands/)  | [Java](src/Problems/GraphsProblems/IslandCount.java) | 1. use BFS or DFS <br>2. dfs returns true if all checks are valid, else returns false <br>3. if dfs returns true, increment count | O(M*N)  | 
| 18   | [Remove Nth Node From End of List](https://leetcode.com/problems/number-of-islands/)  | [Java](src/Problems/LinkedLists/RemoveNodeFromEnd.java) | 1. get the node position from head <br>2. traverse to the node before the to delete node | O(N)  | 
| 20   | [Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/)  | [Java](src/Problems/SlidingWindow/MaxAverage.java) | 1. sliding window <br>2. calculate the sum of the first window <br>3. slide the window and recalculate the max sum <br>4. return maxSum/windowSize | O(N)  | 
| 21   | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)  | [Java](src/Problems/SlidingWindow/LongestSubstringWithoutRepeatingCharacters.java) | 1. sliding window <br>2. if char is seen, remove most-left char, else increment our window | O(N)  | Sliding Window
| 22   | [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)  | [Java](src/Problems/SlidingWindow/LongestRepeatingCharacterReplacement.java) | 1. sliding window & hash map <br>2. check if window size - max freq char > k (we exhausted all replacement) <br>3. if true slide left side and decrement char count <br>4. result is equal to the maximum window size | O(N)  | 
| 23   | [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)  | [Java](src/Problems/SlidingWindow/MinimumWindowSubstring.java) |  | O(S + T)  | 
| 24   | [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)  | [Java](src/Problems/Sequences/PalindromicSubstrings.java) | 1. palindromes are like unions, so if we count palnidromes around centers <br>2. center is every character in a string | Time: O(N^2) <br>Space: O(1) | 
| 25   | [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)  | [Java](src/Problems/GraphsProblems/PacificAtlanticWaterFlow.java) |  |  | 
| 26   | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)  | [Java](src/Problems/Sequences/TopKFrequentElements.java) | 1. HashMap to count frequency <br>2. Priority Queue to get max K times | Time: O(N Log(N)) <br> Space: O(N) | 
| 27   | [Validate Binary Tree](https://leetcode.com/problems/validate-binary-search-tree/)  | [Java](src/Problems/Trees/ValidateBinaryTree.java) | 1. validate each subtree <br>2. if curr.val < low || curr.val > high return false | Time: O(N) <br> Space: O(N) | 
| 28   | [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)  | [Java](src/Problems/Trees/InvertBinaryTree.java) | 1. swap children <br>2. call recursive function one for the left side and one for the right side | Time: O(N) <br> Space: O(N) | 
| 29   | [Maximum Sum Subarray of Size K](https://www.educative.io/courses/grokking-the-coding-interview/JPKr0kqLGNP)  | [Java](src/Problems/SlidingWindow/MaximumSumSubarrayOfSizeK.java) | 1. calculate window of size k <br>2. slide the window to the right and track the max value  | Time: O(N) <br> Space: O(1) | Sliding Window
| 30   | [Smallest Subarray With a Greater Sum](https://www.educative.io/courses/grokking-the-coding-interview/7XMlMEQPnnQ)  | [Java](src/Problems/SlidingWindow/MinSizeSubArraySum.java) | 1. increase window size until sum is >= K <br>2. if true, calculate min and increment left <br>3. else incrementright | Time: O(N) <br> Space: O(1) | Sliding Window
| 31   | [Largest Subarray Length K](https://leetcode.com/problems/largest-subarray-length-k/)  | [Java](src/Problems/SlidingWindow/LargestSubarrayLengthK.java) | 1. find largest starting value of a window <br>2. return all elements from start | Time: O(N) <br> Space: O(N) | Fixed Window
| 32   | [Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/submissions/)  | [Java](src/Problems/SlidingWindow/LongestSubstringwithAtMostKDistinctCharacters.java) | 1. ordered hash map <br>2. if we get a seen char, remove it from the map and put the new index <br>3. if the map size > k keep removing left most char and assign left to its index <br>4. keep track of max length | Time: O(N) <br> Space: O(N) | Sliding Window, Hash Map
| 34   | [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)  | [Java](src/Problems/SlidingWindow/FruitIntoBaskets.java) | Same as [Longest Substring with K Distinct Characters](src/Problems/SlidingWindow/LongestSubstringwithAtMostKDistinctCharacters.java) | Time: O(N) <br> Space: O(1) | Sliding Window, Hash Map
| 35   | [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)  | [Java](src/Problems/Sequences/SubarraySumEqualsK.java) | 1. calculate sum while iterating <br>2. check if sum - k is in the map <br>3. if yes then our map has the desired sum  | Time: O(N) <br> Space: O(N) | Hash Map
| 36   | [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)  | [Java](src/Problems/Trees/BinaryTreeRightSideView.java) | 1. DFS and keep incrementing depth <br>2. if depth is larger than result size then add | Time: O(N) <br> Space: O(H) - H is a tree height | DFS
| 37  | [Permutation in String](https://leetcode.com/problems/permutation-in-string/) | [Java](src/Problems/Sequences/PermutationInString.java) | sort each substring and check if equal | O(L1Log(L1) + (L2 - L1)*L1Log(L1))
| 38  | [Find Missing Number](https://leetcode.com/problems/missing-number/) | [Java](src/Problems/Sequences/FindMissingNumber.java ) | calculate expected sum - actual sum | T: O(N) <br>S: O(1)
| 39  | [Find Disappeared Numbers](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/) | [Java](src/Problems/Sequences/FindDisappearedNumbers.java) | 1. mark the index of each num as negative <br>2. check if all numbers are negative | T: O(N) <br>S: O(1)
| 40  | [Find Duplicate Numbers](https://leetcode.com/problems/find-all-duplicates-in-an-array/) | [Java](src/Problems/Sequences/FindDuplicateNumbers.java) | 1. mark the index of each num as negative <br>2. if num in the index is already negative, then it's a duplicate | T: O(N) <br>S: O(1)
| 41  | [Minimum Absolute Difference](https://leetcode.com/problems/minimum-absolute-difference/) | [Java](src/Problems/Sequences/MinimumAbsoluteDifference.java) | 1. sort the array <br>2. calculate min diff while traversing <br>3. if equal to min diff pairs, then add to result <br>4. else, clear result and update min diff pairs | Time: O(log(N)) <br> Space: O(1) |
| 42  | [Word Search](https://leetcode.com/problems/word-search/) | [Java](src/Companies/facebook/WordSearch.java) | DFS | Time: O() <br> Space: O() |
| 43  | [Make Two Arrays Equal by Reversing](https://leetcode.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/) | [Java](src/Companies/facebook/CanBeEqual.java) | 1. sort the two arrays <br>2. return false if they're not equal | Time: O(N*log(N)) <br> Space: O(1) |
| 44  | [Passing Yearbooks](https://leetcode.com/discuss/interview-question/614096/facebook-interview-preparation-question-passing-yearbooks) | [Java](src/Companies/facebook/PassingYearbooks.java) | 1. start from student 1 <br>2. at the beginning the owner and the curr holder are the same <br>3. prev student signs the book <br>3. change the curr holder to the prev student <br>4. if owner == curr holder, we stop| Time: O( ) <br> Space: O(1) |
| 45  | [Pair Sums](https://leetcode.com/problems/combination-sum/) | [Java](src/Companies/facebook/PairSums.java) | 1. create a freq map <br>2. if map contains the complement, then we have to handle two cases: <br> a. if the two numbers are different, then multiply their values <br> b. if the numbers are the same, subtract one from one of the values <br>3. return count / 2 since the algo. is calculating the work twice for the same pair | Time: O(N) <br> Space: O(N) |
| 46  | [Combination Sum](https://leetcode.com/problems/combination-sum/) | [Java](src/algorithms/other/recursion/CombinationSum.java) | 1. same as fining a combination in an array <br>2. keep subtracting targetSum, and if == 0, add to our result | Time: O(N^(T/M + 1)) <br> Space: O(T/M) |
| 47  | [Weak Characters in the Game](https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/) | [Java](src/Companies/google/WeakCharactersInTheGame.java) | 1. sort attacks in a descending order, if attack is the same then sort defense in ascending order <br>2. keep track of max <br>3. if defense value is less than max, then add it to the result | Time: O(N*log(N))) <br> Space: O(1) |
| 48  | [Contiguous Subarrays](https://leetcode.com/discuss/interview-question/579606/count-contiguous-subarrays) | [Java](src/Companies/facebook/ContiguousSubarrays.java) | 1. use a stack to go from left to right, then from right to left <br>2. while traversing, if the top of the stack < arr[i], then we keep popping and increment our result cell <br>3. we do the same from right to left, but with a fresh temp array so we can get the counts without being affected by the previous pass | Time: O(N) <br> Space: O(N) |
| 49  | [Rotational Cipher](https://www.hackerrank.com/challenges/caesar-cipher-1/problem) | [Java](src/Companies/facebook/RotationalCipher.java) | 1. iterate through each character <br>2. check if letter, digit, else <br>3. using ascii table, we can subtract the value of the char from 'A' or '0', then add # rotations, and then add 'A' or '0' again to convert it back to a string | Time: O(N) <br> Space: O(N) |
| 50  | [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) | [Java](src/Companies/facebook/BasicCalculatorII.java) | the idea here is to have a currNum and lastNum vars. <br>currNum would parse the currNum and lastNum would perform the operation if we fulfilled or conditions <br>  1. iterate through each char <br>2. if digit, then add it to a var currNum <br>3. if operation OR last char, then check which operation <br>4. if it's + or -, then we want to add lastNum seen to the result <br>5. if * or /, then we want to apply that to the lastNum seen <br>6. reset currNum and update operation | Time: O(N) <br> Space: O(1) |
| 51  | [Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/) | [Java](src/Problems/Trees/MergeTwoBinaryTrees.java) | 1. handle null nodes <br>2. root1.val = root1.val + root2.val <br>3. root1.left = recursive call and pass left for both trees <br>4. root1.right = recursive call and pass right for both tree <br>5. return root1 | Time: O(N + M) <br> Space: O(N) |
| 52  | [Buildings With an Ocean View](https://leetcode.com/problems/buildings-with-an-ocean-view/) | [Java](src/Companies/facebook/OceanView.java) | 1. iterate from the end and track max <br>2. if building is greater than curr max, then it has an ocean view | Time: O(N) <br> Space: O(1) |
| 53  | [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) | [Java](src/Problems/LinkedLists/IntersectionOfTwoLists.java) | the idea is similar to fast and slow pointers <br> 1. create a temp pointer for each head <br>2. while both pointers are not the same, we iterate. And if we reach null, then we set the pointer to the other head | Time: O(N+M) <br> Space: O(1) |
| 54  | [Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | [Java](src/Problems/Trees/LCAInBinarySearchTree.java) | the idea is to find the condition where left child is less than parent, and right child is greater than parent | Time: O(N) <br> Space: O(1) |
| 55  | [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/) | [Java](src/Problems/Trees/LCAInBinaryTree.java) | 1. base case: root == null, return null <br>2. base case: root == p or q, return root <br> 2. recursive case: search in the left subtree, search in the right subtree <br>3. if both left & right are null, then return null <br> 4. if either are not null, return the one that's not null <br>5. if both are not null then we find the parent and we return it | Time: O(N) <br> Space: O(N) |
| 56  | [Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/) | [Java](src/Problems/Trees/LCAInBinaryTreeII.java) | same approach as [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/) but we need to explore all nodes to make sure that we have both p & q <br> we can use a boolean for that | Time: O(N) <br> Space: O(N) |
| 57  | [Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/) | [Java](src/Problems/Trees/LCAInBinaryTreeIII.java) | same approach as [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/) OR [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) | Time: O(N) <br> Space: O(N) |
| 58  | [Verifying an Alien Dictionary](https://leetcode.com/problems/verifying-an-alien-dictionary) | [Java](src/Companies/facebook/VerifyingAlienDictionary.java) | 1. get the ordering of the characters <br>2. compare each word to the next <br>3. if prev word is greater than the next one, then return false | Time: O(N*M) <br> Space: O(1) |
| 59  | [Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/) | [Java](src/Problems/dynamicProgramming/MinCostForTickets.java) | 1. Have 3 queues for each ticket duration <br>2. iterate through each day <br>3. remove all expired tickets from the three queues <br>4. add all 3 possible options to the queues <br>5. track minCost and return it | Time: O(N) <br> Space: O(1) |
| 60  | [Coin Change](https://leetcode.com/problems/coin-change/) | [Java](src/Problems/dynamicProgramming/CoinChange.java) | 1. create a table of size amount + 1 and fill with max value <br> 2. base case: dp[0] = 0 <br>3. recursive case: iterate through the table cells <br>4. if num - coin > 0, then get the min of the current cell and 1 + dp[num - coin] | Time: O(N*C) <br> Space: O(C) |
| 61  | [Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/) | [Java](src/Problems/Trees/BinaryTreeVerticalOrder.java) | 1. create map to store col and list nodes that share the same col <br>2. create a queue for BFS approach <br>3. while queue is not empty, we poll and check if our map has the column and add the value to the list <br>4. if left!=null, we add it to the queue with col -1 <br>5. if right!=null, we add it to the queue with col+1 <br>6. to get columns in order, we have a min and max vars to track columns, and then we fill our result from min -> max | Time: O(N) <br> Space: O(N) |
| 62  | [Binary Tree Vertical Order Traversal II](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/) | [Java](src/Problems/Trees/BinaryTreeVerticalOrderII.java) | 1. same as [Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/) <br>2. additionally, we need store every row and col of each node <br>3. before adding column list to the result, we need to have a custom comparator to sort values in the same row and same col | Time: O(N*Log(N)) <br> Space: O(N) |
| 63  | [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/) | [Java](src/Companies/facebook/MakeParenthesesValid.java) | the idea is to eliminate pairs as we iterate through the string. <br>1. keep track of open a close parentheses <br>2. if char is closing, decrement open if > 0  <br>3. else, increment close <br>3. return the sum of open and close | Time: O(N*Log(N)) <br> Space: O(N) |
| 64  | [Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/) | [Java](src/Companies/facebook/MinRemoveToMakeValidParentheses.java) | the idea is to store all invalid open and close parentheses <br>1. create a stack and a hash set to store indices <br>2. if ')', then increment open <br>3. if '(' then pop the top in the stack. if stack is empty then then we need to remove the ')', so we add it to the set <br>4. add any indices left in our stack to the set <br>5. iterate again through the string and skip the indices in the set | Time: O(N)) <br> Space: O(N) |
| 65  | [Count Binary Substrings](https://leetcode.com/problems/count-binary-substrings/) | [Java](src/Problems/Sequences/CountBinarySubstrings.java) | 1. variables to track pervious and current run length of substrings <br>2. if same char, increase current length <br>3. else, assign its value to prev and reset current len <br>4. if prev len >= curr len; meaning that we have a valid group, increase our result  | Time: O(N) <br> Space: O(1) |
| 66  | [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) | [Java](src/Problems/matrixBFS/RottingOranges.java) | 1. add all rotten oranges to queue and count fresh oranges <br>2. perform BFS and add cell neighbors to the queue if it's a fresh orange <br>3. increment elapsed time | Time: O(N * M) <br> Space: O(N * M) |
| 67  | [Detonate the Maximum Bombs](https://leetcode.com/problems/detonate-the-maximum-bombs/) | [Java](src/Problems/Graphs/DetonateMaxBombs.java) | 1. iterate through each bomb <br>2. call dfs or bfs to get max count <br>3. inside dfs of bfs, iterate through the bombs and check if the next bomb is in the range of the current bomb. | Time: O(N^2) <br> Space: O(N) |
| 68  | [Number of Provinces](https://leetcode.com/problems/number-of-provinces/) | [Java](src/Problems/Graphs/NumberOfProvinces.java) | 1. typical DFS <br>2. keep track of count | Time: O(N^2) <br> Space: O(N) |
| 69  | [Reorder Data in Log Files](https://leetcode.com/problems/reorder-data-in-log-files/) | [Java](src/Problems/Sequences/ReorderLogs.java) | 1. custom comparator <br>2. split the log into an identifier and content | Time: O(M * Nlog(N)) <br> Space: O(M*log(N)) |
| 70  | [First Unique Character](https://leetcode.com/problems/first-unique-character-in-a-string/) | [Java](src/Problems/Sequences/FirstUniqueCharacter.java) | 1. a hash map to count freq | Time: O(N) <br> Space: O(N) |
| 71  | [Integer to Roman](https://leetcode.com/problems/integer-to-roman/) | [Java](src/Problems/Sequences/IntegerToRoman.java) | greedy approach where we start from the largest value and keep subtracting our number <br>1. create an array for symbols and values <br>2. iterate through values <br>2. while values[i] <= num, keep subtracting and add symbol[i] to the result  | Time: O(N) <br> Space: O(1) |
| 72  | [Roman to Integer](https://leetcode.com/problems/roman-to-integer/) | [Java](src/Problems/Sequences/RomanToInteger.java) | 1. a map to hold roman values <br>2. iterate from the end of the string <br>3. if curr char value < prev subtract from sum <br> else, add to sum <br> 4. prev = curr| Time: O(N) <br> Space: O(1) |
| 73  | [Reverse Integer](https://leetcode.com/problems/reverse-integer/) | [Java](src/Problems/Sequences/ReverseInteger.java) | 1. use string builder to easily reverse a number and then apply the sign. OR <br> use division and mod operator to parse the digits <br> make sure to handle overflow cases | Time: O(N) <br> Space: O(1) |
| 74  | [Favorite Genre](https://leetcode.com/discuss/interview-question/373006) | [Java](src/Companies/amazon/FavoriteGenres.java) | 1. create a map for songs genres <br>2. iterate through each user and create a count map and track max <br>3. iterate through count map and if value == max, then add genre to the user favorite genre | Time: O(G*(G+S) <br> Space: O(S) |
| 75  | [Walls and Gates](https://leetcode.com/problems/walls-and-gates/) | [Java](src/Problems/Graphs/WallsAndGates.java) | 1. BFS <br> 2. add all gates cells to the queue <br>2. process the queue <br>3. if parent room < curr room, then update current room and add it to the queue | Time: O(N*M) <br> Space: O(N*M) |


# Grokking the Coding Interview
|  #  | Title                                                   | Solution                                      | Pattern           |
| --- | ------------------------------------------------------- | --------------------------------------------- |------------------ |
|  8  | [Two Sum](https://leetcode.com/problems/max-consecutive-ones/) | [Java](src/Problems/SlidingWindow/MaxConsecutiveOnes.java) | use hash map if array is not sorted <br>1. expand window to the right and keep count of 1s <br>2. if 0, then reset count | Two Pointers



# Companies 

## Google
|  #  | Title                                                   | Solution                                      | Type              |
| --- | ------------------------------------------------------- | --------------------------------------------- |------------------ |
|  1  | [Valid Word Square](https://leetcode.com/problems/valid-word-square/) | [Java](src/Companies/google/RobotRoomCleaner.java) | String Manipulation |
|  2  | [Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/) | [Java](src/Companies/google/CountCompleteTreeNodes.java) | Trees, Recursion |
|  3  | [Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/) | [Java](src/Companies/google/LongestIncreasingPathInMatrix.java) | Recursion |
|  4  | [Robot Room Cleaner](https://leetcode.com/problems/robot-room-cleaner/) | [Java](src/Companies/google/RobotRoomCleaner.java) | Recursion |
|  5  | [Android Unlock Patterns](https://leetcode.com/problems/android-unlock-patterns/) | [Java](src/Companies/google/AndroidUnlockPatterns.java) | Recursion |
|  6  | [Weak Characters in the Game](https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/) | [Java](src/Companies/google/WeakCharactersInTheGame.java) | Arrays |


## Facebook
|  #  | Title                                                   | Solution                                      | Type              |
| --- | ------------------------------------------------------- | --------------------------------------------- |------------------ |
|  1  | [Make Two Arrays Equal by Reversing](https://leetcode.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/) | [Java](src/Companies/google/RobotRoomCleaner.java) | Arrays |
|  2  | [Passing Yearbooks](https://leetcode.com/discuss/interview-question/614096/facebook-interview-preparation-question-passing-yearbooks) | [Java](src/Companies/facebook/PassingYearbooks.java)| Arrays |
|  3  | [Pair Sums](https://leetcode.com/problems/combination-sum/) | [Java](src/Companies/facebook/PairSums.java) | Hash Tables |
|  4  | [Contiguous Subarrays](https://leetcode.com/discuss/interview-question/579606/count-contiguous-subarrays) | [Java](src/Companies/facebook/ContiguousSubarrays.java) | Arrays & Stack |
|  5  | [Rotational Cipher](https://www.hackerrank.com/challenges/caesar-cipher-1/problem) | [Java](src/Companies/facebook/RotationalCipher.java) | Strings |
|  6  | [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) | [Java](src/Companies/facebook/BasicCalculatorII.java) | Strings
|  7  | [Word Search](https://leetcode.com/problems/word-search/) | [Java](src/Companies/facebook/WordSearch.java) | Recursion |
|  8  | [Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/) | [Java](src/Problems/Trees/MergeTwoBinaryTrees.java) | Trees | 
|  9  | [Buildings With an Ocean View](https://leetcode.com/problems/buildings-with-an-ocean-view/) | [Java](src/Companies/facebook/OceanView.java) | Arrays | 
| 10  | [Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/) | [Java](src/Problems/Trees/LCAInBinaryTreeIII.java) | Trees |
| 11  | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) | [Java](src/Problems/Permutations/GenerateParentheses.java) | Recursion |
| 12  | [Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/) | [Java](src/Problems/Intervals/IntervalListIntersections.java) | Intervals |
| 13  | [Verifying an Alien Dictionary](https://leetcode.com/problems/verifying-an-alien-dictionary/solution/) | [Java](src/Companies/facebook/VerifyingAlienDictionary.java) | Strings |
| 14  | [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/) | [Java](src/Problems/TreeDepthFirstSearch/SumRootToLeafNumbers.java) | Trees |
| 15  | [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) | [Java](src/Problems/TreeDepthFirstSearch/MaximumPathSum.java) | Trees
| 16  | [Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/) | [Java](src/Problems/Trees/BinaryTreeVerticalOrder.java) | Trees |
| 17  | [Binary Tree Vertical Order Traversal II](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/) | [Java](src/Problems/Trees/BinaryTreeVerticalOrderII.java) | Trees |
| 18  | [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/) | [Java](src/Companies/facebook/MakeParenthesesValid.java) | Strings | 

## Amazon
|  #  | Title                                                   | Solution                                      | Type              |
| --- | ------------------------------------------------------- | --------------------------------------------- |------------------ |
|  1  | [Favorite Genre](https://leetcode.com/discuss/interview-question/373006) | [Java](src/Companies/amazon/FavoriteGenres.java) | Hash Map |


## Uber
|  #  | Title                                                   | Solution                                      | Type              |
| --- | ------------------------------------------------------- | --------------------------------------------- |------------------ |
|  1  | [Two Sum](https://leetcode.com/problems/two-sum/)       | [Java](src/Problems/TwoPointers/TwoSum.java)    | Arrays & Strings  |
|  2  | [First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | [Java](src/Problems/Sequences/FirstandLastPositionOfElement.java) |  Arrays & Strings  |
|  3  | [Group Anagrams](https://leetcode.com/problems/group-anagrams/)  | [Java](src/Problems/Sequences/GroupAnagram.java) | Arrays & Strings  |
|  4  | [Text Justification](https://leetcode.com/problems/text-justification/) |  | Arrays & Strings  |
|  5  | [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)  | [Java](src/Problems/SlidingWindow/MinimumWindowSubstring.java) | Arrays & Strings  |
|  6  | [Validate IP Address](https://leetcode.com/problems/validate-ip-address/)  | [Java](src/Problems/Sequences/ValidateIPAddress.java) | Arrays & Strings  |
|  7  | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)  | [java](src/Problems/LinkedLists/MergeTwoSortedLists.java)  | Linked Lists  |
|  8  | [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)  | [java](src/Problems/LinkedLists/MergeKSortedLists.java)  | Linked Lists  |
|  9  | [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)  | [java](src/Problems/Graphs/ReconstructItinerary.java)  | Graphs  |
|  10 | [Evaluate Division](https://leetcode.com/problems/evaluate-division/)  | [java](src/Problems/Graphs/EvaluateDivision.java)  | Graphs  |
|  11 | [Find Duplicate Subtrees](https://leetcode.com/problems/find-duplicate-subtrees/)  | [java](src/Problems/Trees/FindDuplicateSubtrees.java)  | Trees  |
|  12 | [Print Binary Tree](https://leetcode.com/problems/print-binary-tree/)  | [java]()  | Trees |
|  13 | [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) | [java](src/Problems/Trees/SerializeAndDeserializeBinaryTree.java) | Trees |
|  14 | [Serialize and Deserialize N-ary Tree](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/) | [java](src/Problems/Trees/SerializeAndDeserializeNTree.java) | Trees |
|  15 | [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) | [java](src/Problems/TwoPointers/TrappingRainWater.java)  | Two Pointers  |
|  16 | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/) | [Java](src/Problems/Intervals/MeetingRoomsII.java) | Intervals |
|  17 | [Employee Free Time](https://leetcode.com/problems/employee-free-time/) | [Java](src/Problems/Intervals/EmployeeFreeTime.java) | Intervals |
|  18 | [Merge Intervals](https://leetcode.com/problems/merge-intervals/) | [Java](src/Problems/Intervals/MergeIntervals.java) | Intervals |
|  19 | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | [java](src/Problems/Permutations/LetterCombinationOfPhone.java) | Recursion & Backtracking  |
|  20 | [Subsets](https://leetcode.com/problems/subsets/) | [java](src/Problems/Subsets/Subsets.java)  | Recursion & Backtracking  |
|  21 | [Word Break](https://leetcode.com/problems/word-break/) | [java](src/Problems/DynamicProgramming/WordBreak.java) | DP |






